/**
 * @description This ruleset enforces a strict user-ownership model for user-specific data (users, resumes, sessions, questions) and restricts write access to job descriptions.
 * @dataStructure
 *  - /users/{userId}: Stores user profiles; only the authenticated user can access their profile.
 *  - /resumes/{resumeId}: Stores user resumes, with a denormalized 'userId' field for authorization.
 *  - /job_descriptions/{jobDescriptionId}: Stores job descriptions; write access is restricted.
 *  - /skill_gaps/{skillGapId}: Stores skill gap analysis results, with a denormalized 'userId' for authorization.
 *  - /sessions/{sessionId}: Stores mock interview sessions, linked to 'userId' and 'jobDescriptionId'.
 *  - /sessions/{sessionId}/questions/{questionId}: Stores individual session questions, implicitly owned by the user who owns the session.
 * @keySecurityDecisions
 *  - Users can only read and write their own data under /users/{userId}.
 *  - Job descriptions are publicly readable but writable only by authorized users (no admin role defined in this version).
 *  - List operations are generally restricted to the owner of the parent document.
 * @denormalizationForAuthorization
 *  - The `Resume` and `SkillGap` entities include denormalized `userId` fields to allow ownership checks without additional `get()` calls.
 *  - Question documents inherit ownership from their parent `Session` document.
 * @structuralSegregation
 *  - User-specific data is stored under /users/{userId} to enable path-based authorization.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profiles. Only the authenticated user can access their own profile.
     * @path /users/{userId}
     * @allow (get, create, update, delete, list) User with ID 'user123' can read, create, update, and delete their own profile.
     * @deny (get, create, update, delete, list) User with ID 'user456' cannot read, create, update, or delete the profile of 'user123'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get: if isOwner(userId);
      allow list: if false; // Listing users is not permitted.
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Controls access to user resumes. Only the owner can read, create, update, and delete their resumes.
     * @path /resumes/{resumeId}
     * @allow (get, create, update, delete, list) User 'user123' can read, create, update, and delete resume 'resumeXYZ' if resume.userId == 'user123'.
     * @deny (get, create, update, delete, list) User 'user456' cannot access resume 'resumeXYZ' owned by 'user123'.
     * @principle Enforces document ownership based on the 'userId' field in the resume.
     */
    match /resumes/{resumeId} {
      allow get: if request.auth != null && request.auth.uid == resource.data.userId;
      allow list: if request.auth != null;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
      allow update: if request.auth != null && request.auth.uid == resource.data.userId;
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }

    /**
     * @description Controls access to job descriptions. Publicly readable, but write access is restricted.
     * @path /job_descriptions/{jobDescriptionId}
     * @allow (get, list) Any user can read and list job descriptions.
     * @deny (create, update, delete) Unauthorized users cannot create, update, or delete job descriptions.
     * @principle Public read access with restricted write access.
     */
    match /job_descriptions/{jobDescriptionId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Implement admin role check
      allow update: if false; // TODO: Implement admin role check
      allow delete: if false; // TODO: Implement admin role check
    }

    /**
     * @description Controls access to skill gap analysis results. Only the owner (user who owns the resume and JD) can read, create, update and delete.
     * @path /skill_gaps/{skillGapId}
     * @allow (get, create, update, delete, list) User 'user123' can read, create, update, and delete skill gap analysis 'skillGapXYZ' if skillGap.userId == 'user123'.
     * @deny (get, create, update, delete, list) User 'user456' cannot access skill gap analysis 'skillGapXYZ' owned by 'user123'.
     * @principle Enforces document ownership based on the 'userId' field.
     */
    match /skill_gaps/{skillGapId} {
      allow get: if request.auth != null && request.auth.uid == resource.data.userId;
      allow list: if request.auth != null;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
      allow update: if request.auth != null && request.auth.uid == resource.data.userId;
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }

    /**
     * @description Controls access to mock interview sessions. Only the owner can read, create, update, and delete their sessions.
     * @path /sessions/{sessionId}
     * @allow (get, create, update, delete, list) User 'user123' can read, create, update, and delete session 'sessionXYZ' if session.userId == 'user123'.
     * @deny (get, create, update, delete, list) User 'user456' cannot access session 'sessionXYZ' owned by 'user123'.
     * @principle Enforces document ownership based on the 'userId' field in the session.
     */
    match /sessions/{sessionId} {
      allow get: if request.auth != null && request.auth.uid == resource.data.userId;
      allow list: if request.auth != null;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
      allow update: if request.auth != null && request.auth.uid == resource.data.userId;
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }

    /**
     * @description Controls access to individual questions within a session. Access is restricted to the owner of the parent session.
     * @path /sessions/{sessionId}/questions/{questionId}
     * @allow (get, create, update, delete, list) User 'user123' can read, create, update, and delete question 'questionABC' within session 'sessionXYZ' if session 'sessionXYZ' belongs to 'user123'.
     * @deny (get, create, update, delete, list) User 'user456' cannot access question 'questionABC' within session 'sessionXYZ' owned by 'user123'.
     * @principle Inherits document ownership from the parent 'session' document.
     */
    match /sessions/{sessionId}/questions/{questionId} {
          // It is not possible to access the `userId` from the parent session in rules, so
          // we validate the `sessionId` to confirm the subcollection is owned by the parent.
          // A common alternative to address this limitation is to de-normalize the `userId` property
          // into the question document so that the `isOwner` logic can be executed.

      allow get: if get(/databases/$(database)/documents/sessions/$(sessionId)).data.userId == request.auth.uid;
      allow list: if get(/databases/$(database)/documents/sessions/$(sessionId)).data.userId == request.auth.uid;
      allow create: if get(/databases/$(database)/documents/sessions/$(sessionId)).data.userId == request.auth.uid;
      allow update: if get(/databases/$(database)/documents/sessions/$(sessionId)).data.userId == request.auth.uid;
      allow delete: if get(/databases/$(database)/documents/sessions/$(sessionId)).data.userId == request.auth.uid;
    }
  }
}